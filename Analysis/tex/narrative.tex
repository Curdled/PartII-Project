\documentclass[a4paper]{article}

\begin{document}
\section*{Evaluation outline}
JVHC is the name of my Haskell to JVM bytecode compiler.
\begin{itemize}
  \item Compiler is correct: 
    \begin{itemize}
      \item unit tests examining lots of different programs, and checking
        parts of the compiler in isolation.
      \item Induction over CoreExpr justifying that thunks each expression
        must unwrap all thunks that it must also return a thunk surrounding
        it's self, must justify that all unwraps to thunks preserve 
        any program that should diverge will diverge and 
        any program that should not diverge, doesn't diverge due 
        to unwrapping of thunks in this fashion.
        
      \item Talk about correctness of type inference in terms of  monomorphism
        restriction and in general
      \item Talk about correctness of kind inference.

      \item Maybe look at formal semantics of type-inference
          with custom data-types?

      \item Talk about correctness of inlining, show by induction that
        it doesn't change the type of the whole expression.

      \item Show inlining always terminates, maybe formally if not 
        with unit tests.
    \end{itemize}

  \item Compiler is performant:
    \begin{itemize}
      \item Code size, compare code size of Haskell binary with
        all the \texttt{.class} files output from JVHC in a Jar with the output
        from the Java compiler packaged into a Jar.
      \item Type inference exponential program to type infer with both
        GHC vs JVHC.
      \item Compare native Java, GHC and JHVC (maybe 
        eta\footnote{Haskell to JVM bytecode compiler}) performance of 
        Fibonacci (maybe another program since Robert used this last year?).
      \item Compare Inlining:
        \begin{itemize}
          \item No inlining vs inlining between GHC and JVHC.
          \item Number of stack frames needed to run the \texttt{testN} 
            program.
          \item Compare memory used between inlined and non-inlined program.
          \item Link between stack framed needed and memory usage, can
            also see with extra memory usage we see increase
            GC times, which then implies increased runtime.
          \item Find case where inlining causes problems.
        \end{itemize}
      \item Time at each stage in the compiler, find average time 
        compiler runs for and what stages take most time.
    \end{itemize}

  \item Compiler is useful interfacing with Java: (Maybe move some of this 
    to a conclusion or further work?)
    \begin{itemize}   
      \item Talk about how we can use any Java functions, from Haskell, but 
    we must first write a wrapper to allow JVHC to type check the class, 
    maybe this could be automated, would need to have marshaling between
    Haskell and Java types. Could write test using some of the Java
    standard library?
      \item Talk about how it would be possible have JVHC generate 
        more Java friendly interfaces to Haskell modules? At the 
        moment must pass all parameters as thunks into any
        JVM bytecode method which was generated by JVHC.
\end{itemize}


\end{itemize}
\end{document}
