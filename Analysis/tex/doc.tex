\documentclass[a4paper]{article}

  \usepackage{pgfplots}
  \pgfplotsset{compat=newest}
  %% the following commands are needed for some matlab2tikz features
  \usetikzlibrary{plotmarks}
  \usetikzlibrary{arrows.meta}
  \usepgfplotslibrary{patchplots}
  \usepackage{grffile}
  \usepackage{amsmath}

  \usepackage{csquotes}


  % you may also want the following commands
  % \pgfplotsset{plot coordinates/math parser=false}
  % \newlength{\fheight}\setlength{\fheight}{}
  % \newlength{\fwidth}\
  \newlength\fwidth
  \setlength{\fwidth}{\textwidth}


\begin{document}
\section*{Evaluation outline}
JVHC is the name of my Haskell to JVM bytecode compiler.
I am measuring the following three 
\begin{itemize}
  \item Compiler is correct: 
    \begin{itemize}
      \item Unit tests examining lots of different programs, and checking
        parts of the compiler in isolation.
      \item Induction over CoreExpr justifying that each expression
        must unwrap certain thunks at its leaves, also that  all thunks must
        also return a thunk surrounding
        it's self, must justify that all unwraps to thunks preserve the property:
        \begin{displayquote}
          Any program that should diverge will diverge and 
          any program that should not diverge, doesn't diverge due 
          to unwrapping of thunks in this fashion.
        \end{displayquote}
        
      \item Talk about correctness of type inference in terms of  monomorphism
        restriction and in general
      \item Talk about correctness of kind inference.

      \item Maybe look at formal semantics of type-inference
          with custom data-types?

      \item Talk about correctness of inlining, show by induction that
        it doesn't change the type of the whole expression.

      \item Show inlining always terminates, maybe formally if not 
        with unit tests.
    \end{itemize}

  \item Compiler is performant:
    \begin{itemize}
      \item Code size, compare code size of Haskell binary with
        all the \texttt{.class} files output from JVHC in a Jar with the output
        from the Java compiler packaged into a Jar.
      \item Type inference exponential program to type infer with both
        GHC vs JVHC. See figure~\ref{ti_exp}
      \item Compare native Java, GHC and JHVC (maybe 
        eta\footnote{Haskell to JVM bytecode compiler}) performance of 
        Fibonacci (maybe another program since Robert used this last year?).
        See figure~\ref{fib_timing}
      \item Compare Inlining:
        \begin{itemize}
          \item No inlining vs inlining between GHC and JVHC. 
            See figure~\ref{inlining_t_mgc}
          \item Number of stack frames needed to run the \texttt{testN} 
            program.
            See figure~\ref{stack_frame_op_n}
          \item Compare memory used between inlined and non-inlined program.
            See figure~\ref{inline_mem} and figure~\ref{noinline_mem}
          \item Link between stack framed needed and memory usage, can
            also see with extra memory usage we see increase
            GC times, which then implies increased runtime.
            Could use figure~\ref{nil_il_gc}
          \item Find case where inlining causes problems.
        \end{itemize}
      \item Time at each stage in the compiler, find average time 
        compiler runs for and what stages take most time. 
        See figure~\ref{comp_bench}
    \end{itemize}

  \item Compiler is useful (how does it interface with Java): (Maybe move some of this 
    to a conclusion or further work?)
    \begin{itemize}   
      \item Talk about how we can use any Java functions, from Haskell, but 
    we must first write a interface spec to allow JVHC to type check the class, 
    maybe this could be automated, would need to have marshaling between
    Haskell and Java types, and to parse and infer types of Java programs. 
  \item Could write test using some of the Java standard library (e.g. 
    expose Haskell a method that could download from a network socket)? 
    Would show how Haskell and Java has a type safe interop.
      \item Talk about how it would be possible have JVHC generate 
        more Java friendly interfaces to Haskell modules? At the 
        moment must pass all parameters as thunks into any
        JVM bytecode method which was generated by JVHC.
\end{itemize}


\end{itemize}

\section{Different JHVC peformance plots}

\begin{figure}
  \input{ti_plot.tex}
  \label{ti_exp}
  \caption{This show a plot of time to type check 
    an expression with exponential complexity to type check
    to show that the runtime of my TI algorithm is half of 
    GHC, any larger value take to long to run.}
\begin{verbatim}
u = let {f0 x f = f x x} in
    let {f1 a = f0 a} in
    let {f2 y = f1 (f1 y)} in
    let {f3 j = f2 (f2 j)} in
    let {f4 k = f3 (f3 k)} in
    let {f5 l = f4 (f4 l)} in
    let {f6 m = f5 (f5 m)} in
       \z -> f6 (\b -> b) z
\end{verbatim}
\end{figure}


\begin{figure}
  \input{fibvsGHC_plot.tex}
  \caption{This is a plot of time taken to run  a na\"ive Fibonacci program
  compiled with GHC (\mbox{$\varphi =9.49\times 10^{-8}$}), JHVC ($\varphi = 1.34\times 10^{-7}$) and native Java (\mbox{$\varphi=1.61\times 10^{-9}$}). Constants }
  \label{fib_timing}
\end{figure}


\begin{figure}
  \input{plotStage.tex}
  \caption{This is a plot of time taken in each stage for an average program (I will include
    the program in an appendix}
  \label{comp_bench}
\end{figure}

\begin{figure}
  \input{inline_plot.tex}
  \caption{A plot with and without the inlining optimization turned on, I also include 
    the time spend running a GC for the non-inlined program. This GC 
    accounts for the sudden in time change at $n = \sim 2.7 \times 10^4$.
    The GC never ran for the inlined program. The GC took about $12\%$ of time
     at the $n=\sim 2.7 \times 10^4$ }
   \label{nil_il_gc}
\end{figure}


\begin{figure}
  \input{memUsed_plot.tex}
  \caption{memUsed.}
\end{figure}

\begin{figure}
  \input{gcTime_plot.tex}
  \caption{gc\_time.}
\end{figure}

\begin{figure}
  \input{differentMemAreas.tex}
  \caption{different Mem areas.}
  \label{noinline_mem}
\end{figure}

\begin{figure}
  \input{differentMemAreasOp.tex}
  \caption{different Mem areas op.}
  \label{inline_mem}
\end{figure}

\begin{figure}
  \input{stackGrowth.tex}
  \caption{The largest number of stack frame at any point in the program.}
  \label{stack_frame_op_n}
\end{figure}

\begin{figure}
  \input{runTimeSubGC.tex}
  \caption{The time that \texttt{testN} took to run minus the total GC time.}
  \label{inlining_t_mgc}
\end{figure}

\begin{figure}
  \input{ghc_inlining.tex}
\begin{verbatim}
foo x = x + 1; bar x   = x - 3
even' x = x `mod` 2 == 0

ifThenElse b e1 e2 = case b of 
  True  -> e1
  False -> e2

testN n = ifThenElse (n < 0) 
             n 
             (ifThenElse (even' n) 
                 (testN (foo n)) 
                 (testN (bar n)))
\end{verbatim}
  \caption{Comparison of GHC optimizations vs JHVC optimizations, when given 
    \texttt{testN} as input, this show that functional inlining in 
  JVHC has a very similar effect to the optimizations (including inlining).
  The GHC compiler inlined
  \texttt{[foo,bar,eqInt,ltInt,ifThenElse]}.
  JVHC inlined \texttt{[ltInt, even', foo, bar, ifThenElse]}}
\end{figure}

\end{document}
