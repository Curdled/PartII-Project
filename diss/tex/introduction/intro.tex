\documentclass[float=false, crop=false]{standalone}
\usepackage[subpreambles=true]{standalone}
\usepackage{import}

\usepackage{subfiles}
\usepackage[backend=biber,style=numeric,sorting=none]{biblatex}
\usepackage[pdfborder={0 0 0}]{hyperref}    % turns references into hyperlinks
\usepackage[margin=25mm]{geometry}  % adjusts page layout
\usepackage{graphicx}  % allows inclusion of PDF, PNG and JPG images
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage{import}
\usepackage[font=small,labelfont=bf]{caption}

\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{textcomp}
\usepackage{csquotes}
\usepackage{color}

\usepackage{listings}

\newlength\gwidth
\newlength\gheight
\setlength{\gwidth}{\textwidth}
\setlength{\gwidth}{\textheight}

\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\definecolor{pred}{rgb}{0.9,0,0}
\definecolor{pgrey}{rgb}{0.46,0.45,0.48}

\lstdefinestyle{HaskellStyle}{
  frame=none,
  xleftmargin=2pt,
  stepnumber=1,
  numbersep=5pt,
  numberstyle=\ttfamily\tiny\color[gray]{0.3},
  belowcaptionskip=\bigskipamount,
  commentstyle=\color{pgreen},
  keywordstyle=\color{pblue},
  stringstyle=\color{pred},
  basicstyle=\ttfamily,
  captionpos=b,
  escapeinside={&}{&},
  language=haskell,
  tabsize=2,
  emphstyle={\bf},
  commentstyle=\it,
  showspaces=false,
  columns=flexible,
  showstringspaces=false,
  morecomment=[l]
}

\lstnewenvironment{HaskellLst}{%
  \lstset{style=HaskellStyle}}{}

\usepackage{tikz}
\usepackage{forest}
\usepackage{calc}

\forestset{
  make tab/.style args={#1:#2:#3/#4:#5:#6/#7:#8:#9}{%
    content={%
      \tabcolsep=.6\tabcolsep
      \begin{tabular}{p{\widthof{x}}|p{\widthof{x}}|p{\widthof{x}}}
        #1 & #2 & #3\\\hline#4&#5&#6\\\hline#7&#8&#9
      \end{tabular}}},
  label position r/.initial=right,
  label position b/.initial=below
}

\newcommand{\namefig}{\textbf{Figure}~}

\begin{document}
\section{Motivation}

Functional programming has a strong basis in mathematics, it is
loosely influenced by Church's Lambda calculus, this means
programs written in Haskell are very easy to reason about mathematically.
There are marked trends of programmers moving towards functional 
languages as correctness properties are usually much easier to verify.
Haskell is a functional language first appearing in the 1990s.
It is a pure, lazy functional language. By pure it is meant 
that there are no side effects when functions are run, which means
when a function is run the result will always be the same, every time 
the function is run. Lazy language means that
expressions in the language are only evaluated at the latest possible
point, meaning if an expression is never required by a function, then 
the expression will never be reduced to a value.
The project proposes to implement a Haskell to JVM compiler called 
the Java Virtual-machine Haskell Compiler (JVHC), 
this will allow the benefits of Haskell to be used on the JVM. This means
Haskell code can be run on the JVM, but moreover Haskell code
can take advantage of libraries already written for the JVM. 
The JVM is widely used in industry, and large software companies
have invested heavily into software that works on the JVM. This project
will, therefore, benefit people with large investments in the JVM, 
but also will allow the industry to benefit from Haskell for new and
existing projects.


% \begin{itemize}
%   \item 
%       Functional programming languages can be very useful in solving
%       problems, same for \textcolor{red}{imperative or 
%         object oriented languages}.
%       Having Haskell on the JVM will allow fusion between all 
%       libraries written in JVM based language and the dialect of Haskell
%       supported by JVHC.
%   \item 
%     Haskell is lazy, so can be useful in some problem domains to 
%     use a lazy language, gives more options to users of the JVM.
% \end{itemize}

\section{Overview of Haskell and its runtime}

The Haskell 98 \cite{haskell98-spec} report defines the Haskell language 
and a small standard library.
Haskell can be thought of as a lambda calculus, with an ML-like type system,
but with qualified types \cite{qualified-types}, known in 
Haskell as Type Classes. JVHC will
leave out parts of the standard library, however in the future 
iterations of the compiler these 
features could be implemented, since the features are available via the JVM.
The library is incomplete due to time constraints of the project and
also adding new functionality will not show any new skills.
The compiler will also not support Type classes. The interesting
part of the compiler project will be implementing a lazy language (Haskell)
on the JVM with eager semantics.
It will be useful for take a look at some Haskell definitions to get
an overview of the benefits Haskell can bring to software engineering.
Haskell allows definition of infinite data structures:
\begin{HaskellLst}
nat :: Int -> [Int]
nat x = x : nat (x+1)
\end{HaskellLst}
This defines a function which when given an integer \verb|x| will return 
a list of all the integers starting from \texttt{x}, and going on forever with
each element the successor of the last.
Since this list has no bound on the length it must be the case 
that values are computed only when required, 
this is possible due to the lazy nature of Haskell. 
The first line is an optional type signature, Haskell
uses \verb|::| to denote ``is of type'' and a single \verb|:| to denote cons (list append), unlike ML-like languages. Then \verb|[Int]| signifies a list
of \verb|Int| where \verb|Int| will be a fixed precision 
signed integer as defined in the Haskell 98 report 
\cite[\textsection6.4]{haskell98-spec}.
Then there is a function \verb|take :: Int -> [a] -> [a]| which will
take the first $n$ elements from a list returning a new list with at most
$n$ elements.
If then run 
\begin{HaskellLst}
take 5 (nat 2)
>> [2,3,4,5,6]
\end{HaskellLst}
then this will take the first 5 elements from the infinite list returning 
a finite list (once the expression is evaluated).

After defining some simple syntax a more motivating example is presented
which is inspired by a paper called ``Why Functional Programming Matters''
\cite[\textsection5]{whyfpm}. 
In the following example a possibly infinite game tree for a simple
two player game can be defined 
\begin{HaskellLst}
data Tree a = Node a [Tree a]

repTree :: (Position -> [Position]) -> Position -> Node Position
repTree f x = Node x (map (repTree f) (f x))

gameTree :: Position -> Node Position
gameTree x = repTree moves x
\end{HaskellLst}
We assume that \verb|Position| is a type define elsewhere in the program 
which stores a specific state in the game. 
\verb|moves| will be a function which returns all possible moves given a state.
Then calling \verb|gameTree startPos| will create
a game tree with every single possible move either player can make throughout
the whole game. The game could have infinitely many states, but since
Haskell is a lazy language the next state positions are only computed
when required. \namefig\ref{figure:tictactoeTree} shows the first two level of the game tree.
The value of each node in the game tree is only computed when required. Noughts and
crosses has a finite game tree, however this time data structure can represent games 
with infinite states spaces. This example utilises both features
of Haskell laziness and algebraic data types (ADTs), the laziness allows an 
infinite data type to be store in memory and values will then only be computed when
required. ADTs allow concise definitions of the \verb|Tree| data type.
\begin{figure}
  \centering
\begin{forest}
  TTT/.style args={#1:#2}{
    make tab/.expanded=\forestove{content},
    label={\pgfkeysvalueof{/forest/label position #1}:$#2$}
  },
  TTT*/.style={
    make tab=::/::/::,
    content/.expand once=%
    \expandafter\vphantom\expandafter{\romannumeral-`0\forestov{content}},
    draw=none,
    append after command={(\tikzlastnode.north) edge (\tikzlastnode.south)},
    for descendants={before computing xy={l*=1.2}},
  },
  th/.style=thick,
  for tree={node options=draw, inner sep=+0pt, parent anchor=south, child anchor=north}
%
[x::/::/::, TTT=r:\textcolor{pgrey}{\textsf{Player 1}}
 [x:o:/::/::, TTT=b:]
 [x::o/::/::, TTT=b:]
 [x::/o::/::, TTT=b:]
 [x::/:o:/::, TTT=b:]
 [x::/::o/::, TTT=b:]
 [x::/::/o::, TTT=b:]
 [x::/::/:o:, TTT=b:]
 [x::/::/::o, TTT=r:\textcolor{pblue}{\textsf{Player 2}}]
]
\end{forest}
\caption[Noughts and crosses game states]{First two levels of the set of all game states generated by the 
  \texttt{gameTree} function with the starting state at the top of 
  the tree signified by the label \textcolor{pgrey}{\textsf{Player 1}}.}
\label{figure:tictactoeTree}
\end{figure}
With care it is possible to define a breadth first walk of the tree generating 
a list of each possible move at each state space. 

\begin{minipage}{\linewidth}
\begin{HaskellLst}
breadthFirst :: Tree a -> [a]
breadthFirst x = breadthFirst' [x]
  where
    breadthFirst' ((Node n lfs: ts)) =
      n : breadthFirst' (ts ++ lfs)
\end{HaskellLst}
\end{minipage}
This definition of an infinite length data structure is trivial in 
Haskell due to the lazy nature of the language, implementing
a similar construct in the Java programming language would 
require the laziness to be explicitly specified which 
would obfuscate the intent of the code. 

% \end{tikzpicture}

% \begin{itemize}
%   \item Explanation of simple Haskell features.

%   \item Define terms, lazy, pure, and functional.

%   \item Overview of writing idiomatic Haskell.

%   \item Talk about monads, since they are used throughout the 
%     implementation of the project.
  
%   \item Find an example of code that can be implemented more 
%     elegantly in Haskell then in Java.
% \end{itemize}

\section{Related work}

There are many implementations of the Haskell 98 report.
The de-facto standard implementation is GHC \cite{ghc} (Glasgow Haskell
Compiler), this compiler generates native machine code. There
are implementations that compile Haskell to JVM bytecode, including Eta \cite{eta} and Frege \cite{frege}. 
As other implementations exist I can then 
compare my implementation to these compilers in the evaluation stage
of the project. 

One of the proposed extensions would be to implement an optimization,
I chose functional inlining, however there are other optimizations, which
would work especially well for this compiler. One of these
optimizations would be strictness analysis and
then transformations that can be associated with this analysis. 
However implementing this was not possible given the timescale of the project.


% \begin{itemize}
%   \item Other implementations of Haskell on the JVM include eta and
%     Frege. Then the baseline implementation of Haskell
%     is GHC, which the code for both Frege and eta is forked from (both
%     with their custom back-ends),.

%   \item 
%     Could talk about other possible optimizations, such as strictness
%     analysis, maybe compare to with inlining and justify why
%     inlining was a good choice.
% \end{itemize}

\end{document}
