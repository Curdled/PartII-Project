\documentclass[float=false, crop=false]{standalone}
\usepackage[subpreambles=true]{standalone}
\usepackage{import}

\usepackage{subfiles}
\usepackage[backend=biber,style=numeric,sorting=none]{biblatex}
\usepackage[pdfborder={0 0 0}]{hyperref}    % turns references into hyperlinks
\usepackage[margin=25mm]{geometry}  % adjusts page layout
\usepackage{graphicx}  % allows inclusion of PDF, PNG and JPG images
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage{import}
\usepackage[font=small,labelfont=bf]{caption}

\usepackage{amsmath}

\usepackage{csquotes}
\usepackage{color}

\usepackage{verbatim}

\newlength\gwidth
\newlength\gheight
\setlength{\gwidth}{\textwidth}
\setlength{\gwidth}{\textheight}

\newcommand{\namefig}{\textbf{Figure}~}

\begin{document}

Overall I consider the project a success. I implemented the whole Haskell
pipeline from start to finish, completing each work package on or
before the time outlined in the proposal timeline. I also implemented
all extensions that were proposed in the project proposal. 
All units tests written were passed by the compiler implementation (JVHC). 
A stage of the compiler was even proved correct through
a formal treatment of two simple calculi, a mapping between them
and formal transition semantics. This provided definitive proof that a translation
relation preserved closely the evaluation semantics. This proof was then 
used in the implementation of the code generation stage of the compiler.

The evaluation section showed comparable performance of specific programs
compiled under both JVHC and GHC (JVHC even produced a program to compute
the $n$th Fibonacci number with the same asymptotic complex as the Java
implementation). The \verb|.class| files produced can also be mixed with 
bytecode files produced from \verb|javac|. This allows a software project to
be written in part in Haskell and in part in Java or another JVM based language
such as Scala \cite{scala} or Clojure \cite{clojure}. This demonstrates the 
additional flexibility available to the programmer in choice of source language.
Programs can then be part written in Haskell either in conjunction with already 
existing source code written in a JVM based language or for a new project
where languages can be mixed to gain the benefits offered by each respective language.
The function inlining also
appeared to provided a benefit in performance and memory usage for certain
programs. 
While the JVHC’s initial success has been encouraging, numerous opportunities for improvement are now clear:
\begin{itemize}

\item The code generation stage of the pipeline takes longer than all other stages 
combined. It would be useful to investigate why this stage takes so long 
and develop a solution which runs faster.

\item Inlining is not favourable in all instances, as there are disadvantages associated with both inadequate and overzealous implementation of the optimisation.  Function inlining allows other optimisations, which may deliver performance gains in some cases. However, inlining too frequently could lead to larger code size and possible work duplication. Hence ensuring an optimum degree of inlining is key to efficient compilation of the program. The degree of inlining is dependent on the definition of the heuristics used to define the cost of inlining a given function. As such this compiler would be improved by finding better heuristics to increase the average performance gain from using functional inlining.
\end{itemize}


\section{Summary of completed work}

This is a summary of features which were implemented in the construction
of the JVHC compiler:

\begin{itemize}

  \item Lexer implemented using Alex

  \item Haskell LR(0) parser implemented in Happy

  \item Kind inference algorithm

  \item Type inference algorithm

  \item Algorithm to go from inputted syntax tree to valid
    System F lambda calculus

  \item Function inlining optimisation stage

  \item Constant folding optimisation stage

  \item Code generation stage which outputted a set of \verb|.class|
    files which can be zipped into a \verb|.jar| and executed

  \item Benchmarking framework which allowed programs to be run on the JVM and 
    result to be collected

  \item Analysis of resulting programs generated by JVHC
\end{itemize}
Over the course of this project I have gained many transferable
skills. This is primarily due to the size of the project, the large number of code files handled and the associated complexity. I feel have also improved my own flexibility as a programmer, as I have had to adopt an unfamiliar code-writing style to extract maximum benefit from the language and implement my solutions as elegantly as possible.
This was a significant challenge as the Haskell writing style has little in common with Java or an OOP
programming language, with which I am more familiar. Not only have I become familiar with the underpinning theory of call-by-name, call-by-need and 
call-by-value evaluation, but gained the practical skill necessary to implement call-by-need evaluation
in a call-by-value evaluation scheme. I have developed a working knowledge of the Haskell
type system and implemented an algorithm which can run type inference
for Haskell 98 programs. I have become proficient in evaluating different implementation
choices. Not only was targeting the JVM was obviously a sensible choice due to its widespread use in industry, I believe it also streamlined my own workflow. I was able to focus on higher level concepts and was freed me from work involved in 
implementing stack frames and a garbage collection algorithm. 
In addition, thanks to the JVM’s ubiquity there is an existing collection of tools 
used to debug outputted \verb|.class| files, which spared me a great deal of time. 



\section{Future Work}

In addition to the technical refinements to the current implementation as described above, there is also scope to add further features to improve the compiler:


\begin{itemize}
  \item Strictness analysis -- Verifying that an argument to an
    expression can first be reduced to a value and then passed
    to the function. This could then allow a transformation 
    (reducing to a value before applying as an argument) to be used 
    on extremely small expressions, or expressions that are destined for use in the body of the function. This would allow the JVHC to utilise a more efficient calling convention for those functions deemed to be strict

  \item Dead code elimination -- Some functions in the compiler may never
    be called at runtime. 
    If the complier could be modified to generate no code for such functions this would
    reduce the size of compiled programs, while never
    increasing program size.

  \item User-friendly Interface -- Define a wrapper class
    around the currently outputted \verb|.class| files
    which will improve interaction between Java code and the
    \verb|.class| files generated from JVHC. It would also
    be useful to allow Java functions to be exposed to the JVHC 
    compiler, facilitating use of the \verb|foreign| keyword, 
    as mentioned in the evaluation section.

  \item Implement type classes -- Extend all stages of the pipeline to 
    include type classes as defined by the Haskell 98 report 
    \cite{haskell98-spec}. In conjunction with other minor changes to the first two stages of the pipeline,
    this would make the JVHC fully Haskell 98 compliant

\end{itemize}

\end{document}
