\documentclass[12pt,a4paper,twoside]{article}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage[margin=25mm]{geometry}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{textcomp}
\usepackage[T1]{fontenc}
\usepackage{parskip}
\usepackage{verbatim}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage[normalem]{ulem}
\def\comment#1\done{{\color{blue}#1}}
\def\add#1\done{{\color{red}#1}}
\def\remove#1\done{{\sout{#1}}}
\def\change#1\to#2\done{{\sout{#1}\color{red}#2}}


\begin{document}


\begin{center}
  \Large
  Core to JVM bytecode translation\\[4mm]

  J.~Isaacs

  Originator: J.~Isaacs 

  \today
\end{center}

\section{Expressions}

An expression $E$ in this compiler can be:

\begin{align*}
E ::&= \lambda\ V . E' \\
   &|\ \texttt{let } x = E_1 \texttt{ in} \ E_2\\ 
   &|\ \texttt{case}\ E \ \texttt{of} \ (A_1 \rightarrow E_1, A_2 \rightarrow E_2, \mathellipsis, A_n \rightarrow E_n)\\
   &|\ E\ E'\\
   &|\ V\\\\
V ::&=\ x &&\text{(variable)}\\
   &|\ (\textit{Constructor}\ E_1, \mathellipsis, E_n )\\
   &|\ \textit{literal}
\end{align*}

where $A_i$ is the alternative type constructors for the of the expression $E$ with a type $\tau$
(e.g. if $\Gamma \vdash E : \texttt{bool}$, then $A_i \in \{ \texttt{True},  \texttt{False} \}$).


Variables will be contained inside thunks, such that the expression the variable points to is only reduced 
when needed.

\subsection{Thunk}

A thunk can be thought of as a nullary function (one which takes no arguments) and when required will 
perform a computation. If we have an expression $E$ we can wrap it inside a thunk \[ \lambda (). E \] then 
only when we apply $()$ to this thunk does the computation take place, this allows the
simulation of call-by-name semantics
when the program is being run with call-by-value operation semantics. 

Haskell and my compiler will use an optimization of this, call-by-need (CBNe), where the value in the thunk is only evaluated once and the 
result is cached. When the thunk is evaluated a second time the result of the computation is return without need to compute the value again.


\subsection{JVM Bytecode}

Thunks will be implemented as objects, one object for each thunk needed 
(that is for each variable there will be a thunk that will wrap each variable).
I will use the Java 8 supplier interface have a interface for a thunk before as:


\begin{verbatim}
public interface Supplier<T> {
  T get();
}

public abstract class Thunk<T> implements Supplier<T> {
    private T cache;
    public abstract T eval();
    public T get() {
        if( value == null ) {
            return cache = force();
        }
        return cache;
    }
}
\end{verbatim}

Variable is created using the \texttt{let} construct and in the example \texttt{x a = plus a 1} we have
the lambda \texttt{\textbackslash a -> plus a 1} is bound to the variable \texttt{x}.

\subsubsection{Constructor}

There will be an interface created for each user defined type. 
For each defined type there will be a class for each type constructor. The class will contain a tag which will be unique for each type constructor of this type,
then the class will contain any parameters (wrapped in a thunk) that exists in there definition.

\textcolor{red}{I will leave the stuff about tags until I have researched the JVM more (likely I will go with 
instanceof instead of a table lookup)}

For example \texttt{data T = A a | B | C int} will generate one interface and three classes:

\begin{verbatim}
interface T {
  int getTag();
}
class A {
  private Thunk a;
  int getTag() {
    return 0;
  }
  Thunk getA() {
    a;
  }
}
...
class C {
  private int a;
  int getTag() {
    return 2;
  }
  Thunk getInt() {
    return new Thunk(a);
  }
\end{verbatim}

\subsubsection{literal}

Literal will be represented as primitive type (int and char).

\subsubsection{case}

\textcolor{red}{same as for constructor will decide between instanceof and tag later}
Case will be compiled using a \texttt{tableswitch} statement where the indices will be the tag of type being switched on. For \texttt{int} and \texttt{char} at lookup 
switch will need to be used since the patterns matched on in the case statement could be sparse, consider

\begin{verbatim}
case 42 of
  2  -> 0
  45 -> 1
  x  -> 2
\end{verbatim}

For user defined types the code would look a bit like this:

\begin{verbatim}
case x of
  True  -> 1
  False -> 2

class Thunk_case_x {
  private Boolean x;

  private int i = null
  Think_case_x(Boolean x) {
    this.x = x
  }
  method int unwrap() {
    if n != null
      return i
  1  invoke x.getTag
  2  tableswitch 0 to 1:
  3    0: 5  // True
  4    1: 7  // False
  5  set i = 1
  6  return i
  7  set i = 2
  8  return i
  }
}
\end{verbatim}

where x is of type \texttt{Boolean} (\texttt{data Bool = True | False}).

The unwrap function contains both JVM bytecode ish instructions and pesudo-code (\textcolor{red}{I will update this later})

\subsubsection{let} 

I will translate the expression (\texttt{let x = E1 in E2}) to (\texttt{(\textbackslash x -> E2)E1}), then 
this can be compiled using the compilation scheme for \textbf{function} (below).

\subsection{function}

If we have a function then this will take a single argument which will be a thunk and return a single expression. 
This would be implemented as follows:

I will use the Java 8 functional interface for all functions.

(https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html)

\begin{verbatim}
g y = 2
  
x a = \b -> plus (g y) b

class TopLevelEnv {
  Thunk_y getY();
  Thunk_x getX();
}

class Thunk_x implements Thunk<Function<A,Function_b>{
  private TopLevelEnv tle;

  public TopLevelEnv getTle();

  public Thunk_x(TopLevelEnv tle) { this.tle = tle }
  private Function<Thunk<A>,Function_b> eval() {
    return new Function_a(this);
  }
}

class Function_a implements Function<Thunk<A>, Function_b> {
  public Thunk_x t; 
  public Function_a(Thunk_x) {...}
  public Function_a apply(Thunk<A> a) {
    return new Function_b(this,a);
  }
}

class Function_b implements Function<Thunk<B>,Integer> {
  Function_a funa;
  Thunk<A>   a
  public Function_b(Function_a funa, Thunk<A> a) {
    this.funa = funa
    this.a = a;
  }
  public Function_y apply(Thunk<B> b) {
    Function_g fung = funa.t.tle.thunkg.get();
    return plus_1.apply(fung.apply(a.get())).apply(b.get());
  }
}
\end{verbatim}

\comment The main thing to note is that when a function is passed an argument that function will not store the argument it will be
passed to any part of the body of the function that requires the argument. Would it be better to have in the above 
example Function\_a to hold a?\done

\comment Do you think I need to both with accessors or just allow for example Function\_b to access Function\_a.t\done

The environment will passed down by via chaining, that is the object in a given scope
having a references to the object in the scope above. If the current scope is $i$ then scope above is
$i-1$, if the scope is $0$ then the scope above is the top level scope (represented by TopLevelEnv in the above example).


\subsubsection{application}

An example of this is above in the subsection about how function are treated.




\end{document}
