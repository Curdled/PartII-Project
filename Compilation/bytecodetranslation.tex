\documentclass[12pt,a4paper,twoside]{article}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage[margin=25mm]{geometry}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{textcomp}
\usepackage[T1]{fontenc}
\usepackage{parskip}
\usepackage{verbatim}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage[normalem]{ulem}
\def\comment#1\done{{\color{blue}#1}}
\def\add#1\done{{\color{red}#1}}
\def\remove#1\done{{\sout{#1}}}
\def\change#1\to#2\done{{\sout{#1}\color{red}#2}}


\begin{document}


\begin{center}
  \Large
  Core to JVM bytecode translation\\[4mm]

  J.~Isaacs

  Originator: J.~Isaacs 

  \today
\end{center}

\section{Expressions}

An expression $E$ in this compiler can be:

\begin{align*}
E ::&= \lambda\ V . E' \\
   &|\ \texttt{let } x = E_1 \texttt{ in} \ E_2\\ 
   &|\ \texttt{case}\ E \ \texttt{of} \ (A_1 \rightarrow E_1, A_2 \rightarrow E_2, \mathellipsis, A_n \rightarrow E_n)\\
   &|\ E\ E'\\
   &|\ V\\\\
V ::&=\ x &&\text{(variable)}\\
   &|\ (\textit{Constructor}\ E_1, \mathellipsis, E_n )\\
   &|\ \textit{literal}
\end{align*}

where $A_i$ is the alternative type constructors for the of the expression $E$ with a type $\tau$
(e.g. if $\Gamma \vdash E : \texttt{bool}$, then $A_i \in \{ \texttt{True},  \texttt{False} \}$).


Variables will be contained inside thunks, such that the expression the variable points to is only reduced 
when needed.

\subsection{Thunk}

A thunk can be thought of as a nullary function (one which takes no arguments) and when required will 
perform a computation. If we have an expression $E$ we can wrap it inside a thunk \[ \lambda (). E \] then 
only when we apply $()$ to this thunk does the computation take place, this allows the
simulation of call-by-name semantics
when the program is being run with call-by-value operation semantics. 

Haskell and my compiler will use an optimization of this, call-by-need (CBNe), where the value in the thunk is only evaluated once and the 
result is cached. When the thunk is evaluated a second time the result of the computation is return without need to compute the value again.


\subsection{JVM Bytecode}

Thunks will be implemented as objects, one object for each thunk needed 
(that is for each variable there will be a thunk that will wrap each variable).
I will use the Java 8 supplier interface have a interface for a thunk before as:


\begin{verbatim}
public interface Supplier<T> {
  T get();
}

public abstract class Thunk<T> implements Supplier<T> {
    private T value;
    protected abstract T force();
    public T get() {
        if( value == null ) {
            return value = force();
        }
        return value;
    }
}
\end{verbatim}

Variable is created using the \texttt{let} construct and in the example \texttt{x a = plus a 1} we have
the lambda \texttt{\textbackslash a -> plus a 1} is bound to the variable \texttt{x}.

\subsubsection{Constructor}

There will be an interface created for each user defined type. 
For each defined type there will be a class for each type constructor. 
Then the class will contain any parameters (wrapped in a thunk) that exists in there definition.

(If I use the switchtable)
The class will contain a tag which will be unique for each type constructor of this type.

For example \texttt{data T = A a | B | C int} will generate one interface and three classes:

\begin{verbatim}
interface T {
}
class A {
  private Thunk a;
  Thunk getA() {
    a;
  }
}
...
class C {
  private int a;
  Thunk getInt() {
    return new Thunk(a);
  }
\end{verbatim}

\subsubsection{literal}

Literal will be represented as primitive type (int and char).

\subsubsection{case}



For user defined types the code would look a bit like this:

\begin{verbatim}
y x = case x of
  True  -> 1
  False -> 2

public Integer apply() {
  if(n instanceof True) {
    return 1;
  } else (n instanceof False) {
    return 2;
  }
}
\end{verbatim}

where \texttt{n} is of type \texttt{Boolean} (\texttt{data Bool = True | False}).


\begin{verbatim}
case y of
  2  -> 0
  45 -> 1
  x  -> 2
\end{verbatim}

for build-in types I will use a set of cmp instructions such as

\begin{verbatim}
1  bipush 2       
2  if_icmpne 5   2 == y
3  bipush 0      
4  returni       return 0
5  bipush 45
6  pop           remove 2 from stack
7  if_icmpne 10  45 == y
8  bipush 1    
9  returni       return 1
10 pop
11 istore_0      x := y
12 bipush 2      
13 returni       return 2
\end{verbatim}

This assumes that y is already on the top of the stack, and will store the value of \texttt{x} in the local
variable 0.

\subsubsection{let} 

I will translate the expression (\texttt{let x = E1 in E2}) to (\texttt{(\textbackslash x -> E2)E1}), then 
this can be compiled using the compilation scheme for \textbf{function} (below).

\subsection{function}

If we have a function then this will take a single argument which will be a thunk and return a single expression. 
This would be implemented as follows:

I will use the Java 8 functional interface for all functions.

(https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html)

\begin{verbatim}
g y = 2
  
x a = \b -> plus (g a) b

main = x 1 2

public class Environment {
    Thunk_x x;
    Thunk_g g;
}

public class Thunk_x extends Thunk<Function_a>{
    public Environment env;

    public Thunk_x(Environment e) {env=e;}

    @Override
    protected Function_a force() {
        return new Function_a(this);
    }
}

public class Thunk_g extends Thunk<Function<Object,Integer>> {
    Environment e;

    Thunk_g(Environment e) {
        this.e = e;
    }
    @Override
    protected Function<Object, Integer> force() {
        return (Object x) -> 2;
    }
}

public class Function_a implements Function<Thunk<Object>, Function_b> {
    public Thunk_x t;
    Thunk<Object>  a;
    Function_a(Thunk_x x) {
        this.t = x;
    }
    @Override
    public Function_b apply(Thunk<Object> a) {
        this.a = a;
        return new Function_b(this);
    }
}

public class Function_b implements Function<Thunk<Integer>,Integer>{
    Function_a a;
    public Function_b(Function_a a) {
        this.a = a;
    }

    @Override
    public Integer apply(Thunk<Integer> bThunk) {
        Function<Object,Integer> g = a.t.env.g.get();
        Function_Plus plus = new Function_Plus();
        return plus.apply(g.apply(a.a.get())).apply(bThunk.get());
    }
}

public class main {
    public static void main(String[] args) {
        Environment e = new Environment();

        e.g = new Thunk_g(e);
        e.x = new Thunk_x(e);

        Thunk<Object> a = new Thunk<Object>() {
            @Override
            protected Object force() {
                return null;
            }
        };

        Thunk<Integer> b = new Thunk<Integer>() {
            @Override
            protected Integer force() {
                return 2;
            }
        };
        
        e.x.get().apply(a).apply(b); //main call
    }
}
\end{verbatim}

\comment The main thing to note is that when a function is passed an argument that function will not store the argument it will be
passed to any part of the body of the function that requires the argument. Would it be better to have in the above 
example Function\_a to hold a?\done

\comment Do you think I need to both with accessors or just allow for example Function\_b to access Function\_a.t\done

The environment will passed down by via chaining, that is the object in a given scope
having a references to the object in the scope above. If the current scope is $i$ then scope above is
$i-1$, if the scope is $0$ then the scope above is the top level scope (represented by TopLevelEnv in the above example).


\subsubsection{application}

An example of this is above in the subsection about how function are treated.




\end{document}
