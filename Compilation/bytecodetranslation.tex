\documentclass[12pt,a4paper,twoside]{article}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage[margin=25mm]{geometry}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{textcomp}
\usepackage[T1]{fontenc}
\usepackage{parskip}
\usepackage{verbatim}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage[normalem]{ulem}
\def\comment#1\done{{\color{blue}#1}}
\def\add#1\done{{\color{red}#1}}
\def\remove#1\done{{\sout{#1}}}
\def\change#1\to#2\done{{\sout{#1}\color{red}#2}}


\begin{document}


\begin{center}
  \Large
  Core to JVM bytecode translation\\[4mm]

  J.~Isaacs

  Originator: J.~Isaacs 

  \today
\end{center}

\section{Expressions}

An expression $E$ in this compiler can be:

\begin{align*}
E ::&= \lambda\ V . E' \\
   &|\ \texttt{let } x = E_1 \texttt{ in} \ E_2\\ 
   &|\ \texttt{case}\ E \ \texttt{of} \ (A_1 \rightarrow E_1, A_2 \rightarrow E_2, \mathellipsis, A_n \rightarrow E_n)\\
   &|\ E\ E'\\
   &|\ V\\\\
V ::&=\ x &&\text{(variable)}\\
   &|\ (\textit{Constructor}\ E_1, \mathellipsis, E_n )\\
   &|\ \textit{literal}
\end{align*}

where $A_i$ is the alternative type constructors for the of the expression $E$ with a type $\tau$
(e.g. if $\Gamma \vdash E : \texttt{bool}$, then $A_i \in \{ \texttt{True},  \texttt{False} \}$).


Variables will be contained inside thunks, such that the expression the variable points to is only reduced 
when needed.

\subsection{Thunk}

A thunk can be thought of as a nullary function (one which takes no arguments) and when required will 
perform a computation. If we have an expression $E$ we can wrap it inside a thunk \[ \lambda (). E \] then 
only when we apply $()$ to this thunk does the computation take place, this allows the
simulation of call-by-name semantics
when the program is being run with call-by-value operation semantics. 

Haskell and my compiler will use an optimization of this, call-by-need (CBNe), where the value in the thunk is only evaluated once and the 
result is cached. When the thunk is evaluated a second time the result of the computation is return without need to compute the value again.


\subsection{JVM Bytecode}

Thunks will be implemented as objects, one object for each thunk needed 
(that is for each variable there will be a thunk that will wrap each variable).
I will use the Java 8 supplier interface have a interface for a thunk before as:

\textcolor{red}{Should I insist on functions only taking thunks (e.g. if we have \texttt{plus x 1} should I 
create a thunk for \texttt{1} or pass the value 1 to plus, creating a thunk is more uniform. I think creating 
a thunk would be better. That is to say treat function argument as variables.}

\begin{verbatim}
public interface Supplier<T> {
  T get();
}

public abstract class Thunk<T> implements Supplier<T> {
    private T cache;
    public abstract T eval();
    public T get() {
        if( value == null ) {
            return cache = force();
        }
        return cache;
    }
}
\end{verbatim}

Variable is created using the \texttt{let} construct and in the example \texttt{x a = plus a 1} we have
the lambda \texttt{\textbackslash a -> plus a 1} is bound to the variable \texttt{x}.

\subsubsection{Constructor}

There will be an interface created for each user defined type. 
For each defined type there will be a class for each type constructor. The class will contain a tag which will be unique for each type constructor of this type,
then the class will contain any parameters (wrapped in a thunk) that exists in there definition.

\textcolor{red}{I will leave the stuff about tags until I have researched the JVM more (likely I will go with 
instanceof instead of a table lookup)}

For example \texttt{data T = A a | B | C int} will generate one interface and three classes:

\begin{verbatim}
interface T {
  int getTag();
}
class A {
  private Thunk a;
  int getTag() {
    return 0;
  }
  Thunk getA() {
    a;
  }
}
...
class C {
  private int a;
  int getTag() {
    return 2;
  }
  Thunk getInt() {
    return new Thunk(a);
  }
\end{verbatim}

\subsubsection{literal}

Literal will be represented as primitive type (int and char).

\subsubsection{case}

\textcolor{red}{same as for constructor will decide between instanceof and tag later}
Case will be compiled using a \texttt{tableswitch} statement where the indices will be the tag of type being switched on. For \texttt{int} and \texttt{char} at lookup 
switch will need to be used since the patterns matched on in the case statement could be sparse, consider

\begin{verbatim}
case 42 of
  2  -> 0
  45 -> 1
  x  -> 2
\end{verbatim}

For user defined types the code would look a bit like this:

\begin{verbatim}
case x of
  True  -> 1
  False -> 2

class Thunk_case_x {
  private Boolean x;

  private int i = null
  Think_case_x(Boolean x) {
    this.x = x
  }
  method int unwrap() {
    if n != null
      return i
  1  invoke x.getTag
  2  tableswitch 0 to 1:
  3    0: 5  // True
  4    1: 7  // False
  5  set i = 1
  6  return i
  7  set i = 2
  8  return i
  }
}
\end{verbatim}

where x is of type \texttt{Boolean} (\texttt{data Bool = True | False}).

The unwrap function contains both JVM bytecode ish instructions and pesudo-code (\textcolor{red}{I will update this later})

\subsubsection{let} 

I will translate the expression (\texttt{let x = E1 in E2}) to (\texttt{E2' E1}) where all 
free occurrences of \texttt{x} in \texttt{E2} will be replaced by the first argument of 
\texttt{E2'}, which will necessarily be \texttt{E1}.

\comment What about (mutually) recursive functions? \done 
\comment I don't understand the let construct (\texttt{let A in B}) can only have a single function defined in the 
 \texttt{A} part and \texttt{A} cannot reference \texttt{B}, so where is the problem? \done

\subsection{function}

If we have a function then this will take a single argument and return a single expression. This would be implemented as follows:

\begin{verbatim}
x a = \b -> plus a b

class Thunk_x implements Thunk<Function<A,Function_b>{
  private Function<Thunk<A>,Function_b> eval() {
    return new Function_a();
  }
}

class Function_a implements Function<Thunk<A>, Function_b> {
  public Function_a apply(Thunk<A> a) {
    return new Function_b(a);
  }
}

class Function_b implements Function<Thunk<B>,Integer> {
  Thunk<A> a;
  public Function_b(Thunk<A> a) {
    this.a = a;
  }
  public Function_y apply(Thunk<B> b) {
    return plus_1.apply(a.get()).apply(b.get());
  }
}
\end{verbatim}
Above it passing free variables into each successive function call. Below I pass an environment which 
know how to find each of the free variables.
\begin{verbatim}
class Function_b implements Function<B,Integer> {
  EnvFunction_b env;
  public Function_b(EnvFunction_b env) {
    this.env = env;
  }
  public Function_y apply(Thunk<B> b) {
    return plus_1.apply(env.getA().get()).apply(b.get());
  }
}

EnvFunction_b {
  Function_a funa;
  EnvFunction_a parent;
// parent is the environment for any thing outside the scope of x 
  EnvFunction_b (EnvFunction_a parent, Function_a funa) { ... }
  Thunk<A> getA() { return funa.getA() } 
// I assume that Function_a will have a variable A stored.
}
\end{verbatim}

Here we have two options (show in the two definition of Function\_b) I can either have references passed down
or a environment pass down (this would be how I would order the chaining).

\comment You could also do chaining, instead of passing in the closure variables. That is, you pass in parents, then when you have a reference, you just call the correct number of parents. I have ended up using this in my compiler, but forgot why.
\done

\comment I think I will stick the passing variables into each closure since if I pass parents into a
function then each function must know the layout of the parent. I could have an environment class which 
will be passed into each function and will abstract away the about the closure variables are stored. That 
means this call will be responsible for returning variables in outer scopes and then this variable could 
know about the parent not the function its self (shown above). \done





I will use the Java 8 functional interface 

(https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html)


\subsubsection{application}

An example of this is above in the subsection about how function are treated.




\end{document}
