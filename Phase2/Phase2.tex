\documentclass[a4paper]{article}

\usepackage{a4wide}

\newcommand{\al}{$<$}
\newcommand{\ar}{$>$}


\usepackage{lmodern}
\usepackage{textcomp}
\usepackage[T1]{fontenc}

\parindent 0pt
\parskip 6pt

\begin{document}

\thispagestyle{empty}

\rightline{\large Joe Isaacs}
\medskip
\rightline{\large Sidney Sussex (Sid)}
\medskip
\rightline{\large josi2}

\vfil

\centerline{\large Part II Computer Science Project Proposal}
\vspace{0.4in}
\centerline{\Large\bf Haskell to JVM bytecode compiler}
\vspace{0.3in}
\centerline{\large 12/10/16}

\vfil

{\bf Project Originator:} Joe Isaacs

\vspace{0.1in}

{\bf Resources Required:} See attached Project Resource Form

\vspace{0.5in}

{\bf Project Supervisor:} Robert Kovacsics

\vspace{0.2in}

{\bf Signature:}

\vspace{0.5in}

{\bf Director of Studies:}  John Fawcett

\vspace{0.2in}

{\bf Signature:}

\vspace{0.5in}

{\bf Overseers:} Sean Holden and Simone Teufel

\vspace{0.2in}

{\bf Signatures:}

\vfil
\eject



\section*{Introduction and Description of Work}

  I propose to write a compiler for a subset of Haskell98 (from now on I will use Haskell to mean Haskell98, unless specified otherwise)
  in GHC Haskell. I will target JVM bytecode as the output from the compiler.



  Haskell is a pure and lazy functional programming language with strong static typing. Pure meaning that
  if a function is given the same input twice then the output will always be the same. Lazy meaning that Haskell has a
  call-by-need evaluation scheme, a function argument is only evaluated if the function uses that expression in its body
  and if the expression is used then it is memoized [cached] and any subsequent uses are looked up in the cache.
  The JVM on the other hand was  written as a platform independent interpreter designed
  primarily to support the constructs of Java (an object-oriented programming language).
  Therefore the JVM has a C-like call stack (in that when a method is called a new stack frame is created). In the JVM objects are also first-class citizens, this means
  the proposed compiler must bridge the gap between the two, providing mapping between the functions from Haskell to primitives
  the JVM will be able to work with.

  This compiler would allow Haskell to be compiled for a portable platform, the JVM. This allows the programmer to
  write functional lazy code, that can be executed on any platform that the JVM is implemented on. This compiler allows a software project to contain both
  Haskell and Java code. Given a software project written in Java, this new compiler makes it possible to implement extensions to the project in Haskell
  while not having to rewrite the whole project in Haskell.

  The subset of Haskell used in the compiler will contain the following constructs: (Algebraic Data Types) ADTs, case expressions,
  functions, let constructs, char and int.

  One of the extensions I propose would be a construct allowing Haskell functions to run as static and pure functions defined in JVM bytecode.
  The next extension I propose would allow IO in Haskell; using the IO monad as defined in the Haskell spec (part 7) \cite{haskell98-spec}. 
  I would only implement reading from stdin and writing to stdout. Another proposed extension is function inlining discussed below.
  The final extension I propose would be to extend the IO monad such that it would allow Java code to be evaluated from Haskell. The side effect of the codes
  will be packaged  up such that the computation is ordered even with call-by-need (defined below) evaluation semantics.
  This will then be compatible with the Haskell type system.

\section*{Resources Required}
  I will use my own personal laptop (late 2013 MacBook Pro).
  I will backup to Dropbox.
  I will use Github for source control and a second backup.
  I will use the Haskell programming language, which means I will use the GHC and associated libraries.
  I will use the already existing libraries including Alex (lexer generator similar to lex),
  Happy (parser generator similar to yacc) and codec-jvm (a JVM bytecode generator),which is under the Apache 2.0. I am also considering using the same licence.

\section*{Starting Point}
  I have taken the Compiler Construction course in Part IB and am currently taking the Part II course Types. I have spent the summer
  learning Haskell from various places including CIS 194 University of Pennsylvania \cite{cis194} and Real World Haskell \cite{realwordhaskell}.
  I plan to use a library called \textit{codec-jvm} to generate JVM bytecode from an expression I will build up from the core language generated after
  syntactic desugaring. The \textit{codec-jvm} is a library that will allow me to build up a typed expression which will map directly
  to JVM bytecode. This library is just an assembler, I will still need to generate code to implement all of the 
  programming language constructs in JVM bytecode myself.


\section*{Project Description}
  I propose to write a compiler for a subset of Haskell in GHC Haskell. I will use Java to implement a number of classes which will be used in the
  code generation phase of the compiler.

  \subsection*{Core}

  The core part of the project will involve implementing a subset of Haskell which includes the following language features:
  \begin{itemize}
    \item Algebraic Data Types

    \item Named Functions


    \item White-space Insensitive

      Haskell98 specifies that the grammar is white-space sensitive, however this requires complicated parsing and is not the focus of my project so instead I will
      use the tokens \texttt{\{} and \texttt{\}} and \texttt{;} to indicate blocks. This white-space insensitive form is still valid Haskell.
      For example
      \begin{verbatim}
        data Unit = Unit
        f = let driver _ = plus1
          in foldr driver 0
      \end{verbatim}
      would be written as
      \begin{verbatim}
       {data Unit = Unit;
        f = let driver _ = plus1 in {
           foldr driver 0
           }
       }
      \end{verbatim}
      therefore not being white-space sensitive.

    \item Case Expressions

      Without the guard syntax.

    \item Ints

      The compiler will support 32 bit integers which will map directly to the JVM's primitive type of \texttt{int} \cite{jvm-spec8}.

      The compiler will not implement arbitrary precision integers (the \texttt{Integer} type in Haskell).

    \item Chars

      The compiler will support 16-bit unsigned integers, this is similar to the Int support mentioned above. The char construct will be implemented as a
      primitive JVM \texttt{char} type \cite{jvm-spec8}.


  \end{itemize}
  For the purposes of this dissertation neither of the other primitive data types such as float or double will be supported nor will the syntactic sugar for lists 
  or list comprehensions.
  Haskell modules will not be implemented, this means when compiling a single file the prelude will be included by the compiler as we cannot have multi-file programs.
  I will not be implementing record types or type classes. I also require all variable and function names to be unique, which means there will be no need to apply 
  variable renaming, this allows me to ignore this simple task and focus on more challenging problems of code generation and type inference.

  This is an example program that my compiler will accept:

  \begin{verbatim}
    {data Unit = Unit
    ;e c = let { a = \b -> b } in a c
    ;f x y = Tuple (plus y 1) (Cons x "Hello")
    ;g z = case z of {
      Just f -> 'y';
      Nothing -> 'n'
      }
    }
  \end{verbatim}

  Here both \texttt{Tuple} and \texttt{Cons} will be data constructor (\texttt{a -> b -> Tuple a b} and \texttt{a -> List a -> List a}) 
  defined above in the file and \texttt{plus} will be a function of \texttt{Int -> Int}.

  The \texttt{let} construct will only allow a single expression, that is the following construct (\texttt{let e in e'})
  \texttt{e} can only be a single expression.

  \subsection*{Compiler Pipeline}
  The implementation of the compiler will follow a pipeline structure:

  \begin{itemize}
    \item Lexing and Parsing.

      This will be implemented using the Alex and Happy lexer and parser generators.
    \item Syntactic desugaring.

      This stage of the pipeline will apply many rewrite rules to translation this subset of Haskell to a core language inspired by Haskell core \cite{typedcorelink}.
      The core language is simple enough that code generation will be made easier.
    \item Type checking.

     This stage of the pipeline will type check the core language.
    \item Code generation.

     The final stage will generate JVM bytecode using codec-jvm \cite{codec-jvm-link}
  \end{itemize}

  The input to the stage $i$ is the output of the stage $i-1$, the input to the lexer/parser is Haskell source encoded as ASCII text and the
  output from code generation is a \texttt{.class} or \texttt{.jar} file. 

  \subsection*{Extensions}

  I propose the following extensions:

  \begin{itemize}
    \item Function Inlining

      Function Inlining works by replacing function calls with the body of the function being called \cite{ghc-inliner}.
      This requires heuristics to yield a performance increase, and will allow a comparison between execution speed before and after this optimisation.

    \item A construction to allow pure and static class functions to be invoked from Haskell code in a type safe manner.

      The purity is a guarantee that the programmer will make about the bytecode function being executed.
      There will also be no compiler checking that the type in the Haskell source matches up with the JVM bytecode since this would require inspecting the bytecode which
      would be time consuming and not the purpose of this project. I will also only support input and output of the \texttt{int} and \texttt{char} types since
      marshalling of types between Haskell and JVM bytecode will not be implemented. I Will not implement any other type marshalling since it will show no new
      skills, but take time I could spend implementing different concepts.

    \item Implement the functions allowing reading from stdin and writing to stdout, this tree of computation would be sequenced by the IO monad.

    \item Extend the IO monad to allow Haskell code to interact with compiled Java classes in a controlled manner (without side effects).

  \end{itemize}

  \section*{Success Criteria}

  The following criteria should be achieved:

  \begin{itemize}

    \item
      I will run unit tests which include valid and invalid Haskell programs, making sure valid programs compile and produce the correct result and invalid
      programs will not compile and produce errors. I will also develop unit tests for individual stages in the compiler to test the implementation of these stages
      in isolation.

      I will create my own tests since my subset of Haskell is not a fixed form language.

    \item 

      I will compile and run simple programs on both GHC and my compiler and compare the asymptotic complexity of the 
      compiled code outputted from both compilers. I can plot graphs for different sized inputs, 
      this will show approximate asymptotic complexity of executing a given program compiled by both my compiler and GHC.

    \item

      I will compare the performance (the speed of compilation and speed of generated code) between both my compiler and GHC.

    \item

      [Extension] Support for function inlining. This would result in a comparison between code compiled with and without inlining enabled. I can also
      compare the size of the outputted code with and without this optimisation. I will generate graphs looking at number of passes of the inlining 
      optimization against speed of outputted code and size of outputted code.

    \item 

      [Extension] Add a counter to each function call allowing the number of function calls made in a given execution of a
      program to be counted. I can then graph number of function calls against number of runs of the inliner.

    \item

      [Extension] Support for IO. This would be support for reading from and writing to stdin/stdout in Haskell using an IO monad.
      This would allow me to use the \texttt{invoke} features of the JVM to invoke part of the Java standard library for IO.

    \item

      [Extension] Support for Haskell calling pure Java functions.
      My compiler will allow Haskell programs the ability to call static functions defined in \texttt{.class} files separately. 
      The functions defined in the bytecode file will only have the type:
      
      \begin{verbatim}
       t ::=  t -> t
            | char 
            | int
      \end{verbatim}

    \item

      [Extension] Support for Haskell calling Java functions via the IO monad.

      This would allow Haskell to interact specific Java classes in a type safe manner with no side effects.

  \end{itemize}

  \section*{Timetable}


    \subsection*{20/10/16 - 02/11/16 \hfill Michaelmas Term Week 3,4}

      Consider the core language which will be generated part way through the pipeline and come up with
      a translation from this core language to JVM bytecode.
      Then using Alex to create a lexer and parser for the subset of the Haskell being considered.


      \textbf{Milestone:} Have unit tests for tokenizing Haskell source into a stream of tokens and create an AST from these tokens. All units tests must pass.

      \textbf{Milestone:}
      Create a document that show mappings from core language to JVM bytecode and discuss this document with my supervisor.


    \subsection*{03/11/16 - 16/11/16 \hfill Michaelmas Term Week 5,6}


      Create the syntactic desugaring part of the pipeline. This will go from the parsed syntax tree to the core language.
      Generate a document about typing this core language.
     
      \textbf{Milestone:} Have unit tests for desugaring the AST into core language that run successfully. 
      Discuss this document with my supervisor.


    \subsection*{17/11/16 - 30/11/16 \hfill Michaelmas Term  Week 7,8}

      Implement a type inference algorithm for the (int, chars, functions and function application).

      \textbf{Milestone:} Unit tests checking that type inference works for int, char, functions and function application.

    \subsection*{01/12/16 - 14/12/16 \hfill Christmas Holiday Week 1,2}

    Finish implementing the type inference algorithm. This will require typing the following constructs: ADT and case.
    
    \textbf{Milestone:} Implement unit tests that show the correctness of the typing algorithm. 

    \subsection*{15/12/16 - 04/01/17 \hfill Christmas Holiday Week  3,4,5}

    Slack. If the type inference algorithm takes longer to implement I have left myself extra time.

    \subsection*{05/01/16 - 18/01/17 \hfill Christmas Holiday Week 6,7}

    Start looking at the code generation part of the pipeline.

    \textbf{Milestone:} Compile to bytecode and run a very simple Haskell program (e.g. main = plus 2 2).

    \textbf{Milestone:} Can generate bytecode for functions, function application, let construct, int and char.

    \subsection*{19/01/17 - 01/02/17 \hfill Lent Term Week 1,2}

    Continue with and finish the code generation. 

    Write the progress report.

    \textbf{Milestone:} Can generate bytecode for ADTs and case expressions.
    
    \textbf{Milestone:} Be able to compile more complex programs to JVM bytecode.

    \textbf{Milestone:} Have finished progress report.

    \subsection*{02/02/17 - 15/02/17 \hfill Lent Term Week 3,4}
      
      Evaluate the asymptotic performance of my compiler against GHC.

      Start implementing the function inlining. Create a testing frame work that will allow benchmarking the runtime with and without the
      inlining of functions.


      \textbf{Milestone:} Hand in Progress Report (due Friday 3rd Feb at Noon).

    \subsection*{16/02/17 - 01/03/17 \hfill Lent Term Week 5,6}

      Start writing the introduction chapter of the dissertation. Implement the Haskell invocation of pure and static Java code.

      \textbf{Milestone:} Have generated graphs of asymptotic performance of my compiler against GHC.

    \subsection*{02/03/17 - 15/03/17 \hfill Lent Term Week 7,8}

      Write the implementation chapter of the dissertation.

      Gather data comparing function inlining vs no function inlining.

     \textbf{Milestone:} Have generated graphs comparing function inlining vs no function inlining

    \subsection*{16/03/17 - 29/03/17 \hfill Easter Holiday Week 1,2}

      Finish writing the implementation part of the dissertation.
      Allowing time to catch up with previous weeks work if not done.

      \textbf{Milestone:} Have sent implementing part of the dissertation to supervisor for feedback.

    \subsection*{30/03/17 - 12/04/17 \hfill Easter Holiday Week 3,4}

      Write the evaluation of the dissertation.

      \textbf{Milestone:} Have written whole dissertation and sent to supervisor for review.


    \subsection*{13/04/17 - 26/04/17 \hfill Easter Holiday Week 5,6}

      Slack to finish any loose ends. Get feedback from supervisor and make changes to the dissertation.


    \subsection*{27/04/17 - 10/05/17 \hfill Easter Term Week 1,2}

      Finish the dissertation. Correct any mistakes and incorporate any changes suggested from my supervisor.


    \subsection*{11/05/17 - 17/05/17 \hfill Easter Term Week 3}
      Hand in the dissertation.

     \textbf{Milestone:} Hand in dissertation (deadline noon on Friday 19th May at 12pm).

     \textbf{Milestone:} Hand in supervisor's form by Wed 24th May (4pm).


  \begin{thebibliography}{}
    \bibitem{cis194}
    CIS 194 University of Pennsylvania
    http://cis.upenn.edu/~cis194/spring15/  
    \hbox{[Accessed: 16 October 2016]}

    \bibitem{realwordhaskell}
    Real World Haskell
    http://book.realworldhaskell.org/read/ 
    \hbox{[Accessed: 16 October 2016]}

    \bibitem{typedcorelink}
    GHC Haskell Core
    https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType
    \hbox{[Accessed: 16 October 2016]}


    \bibitem{codec-jvm-link}
    Codec JVM Library
    https://github.com/rahulmutt/codec-jvm  
    \hbox{[Accessed: 16 October 2016]}

    \bibitem{ghc-inliner}
    Secrets of the Glasgow Haskell Compiler Inliner,
    https://www.cambridge.org/core/journals/journal-of-functional-programming/article/secrets-of-the-glasgow-haskell-compiler-inliner/8DD9A82FF4189A0093B7672193246E22   
    \hbox{[Accessed: 16 October 2016]}

    \bibitem{haskell98-spec}
    Haskell98 Revised Report December (2002)
    https://www.haskell.org/onlinereport/
    \hbox{[Accessed: 16 October 2016]}

    \bibitem{jvm-spec8}
    Lindholm, Tim et al.
    The Java Virtual Machine Specification, Java SE 8 Edition (2015-02-13)
    https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf 
    \hbox{[Accessed: 16 October 2016]}


  \end{thebibliography}
\end{document}
